"""
Policy Draft Schemas - Data models for policy generation.

Sprint 3: PolicyDraftAgent generates draft policies for human review.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator


class TestScenario(BaseModel):
    """
    A test scenario showing expected policy behavior.

    Used to validate that generated rules work as intended.
    """

    description: str = Field(..., description="Description of the scenario")
    input_signals: List[Dict[str, Any]] = Field(
        ...,
        description="Input signals for this scenario"
    )
    expected_result: str = Field(
        ...,
        description="Expected evaluation result: pass, fail, or exception_raised"
    )
    expected_exception_severity: Optional[str] = Field(
        None,
        description="Expected exception severity if exception_raised"
    )
    notes: Optional[str] = Field(None, description="Additional notes")


class PolicyDraft(BaseModel):
    """
    A draft policy version generated by PolicyDraftAgent.

    SAFETY INVARIANTS:
    - Rule definitions must be deterministically evaluatable
    - Only use signal types from target pack vocabulary
    - Never auto-approve - all drafts go to approval queue
    - Include test scenarios showing expected behavior
    """

    name: str = Field(..., description="Policy name")
    description: str = Field(..., description="Policy description")
    rule_definition: Dict[str, Any] = Field(
        ...,
        description="Deterministic rule definition (must be evaluatable)"
    )
    signal_types_referenced: List[str] = Field(
        ...,
        description="Signal types this policy evaluates"
    )
    change_reason: str = Field(
        ...,
        description="Reason for creating/updating this policy"
    )
    pack: str = Field(default="treasury", description="Target pack")
    draft_notes: Optional[str] = Field(
        None,
        description="Agent's reasoning about rule construction"
    )
    test_scenarios: List[TestScenario] = Field(
        default_factory=list,
        description="Test scenarios showing expected behavior"
    )
    policy_id: Optional[str] = Field(
        None,
        description="Existing policy ID if updating"
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this draft was created"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Ensure name is not empty."""
        if not v or not v.strip():
            raise ValueError("Policy name cannot be empty")
        return v.strip()

    @field_validator("rule_definition")
    @classmethod
    def validate_rule_definition(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Ensure rule definition has required structure."""
        if not v:
            raise ValueError("Rule definition cannot be empty")
        if "type" not in v:
            raise ValueError("Rule definition must have 'type' field")
        return v

    @property
    def is_update(self) -> bool:
        """Check if this is an update to existing policy."""
        return self.policy_id is not None


class PolicyDraftResult(BaseModel):
    """Result of generating a policy draft."""

    draft: PolicyDraft = Field(..., description="The generated draft")
    approval_id: Optional[str] = Field(
        None,
        description="Approval queue ID if submitted"
    )
    validation_errors: List[str] = Field(
        default_factory=list,
        description="Validation errors found"
    )
    generation_notes: Optional[str] = Field(
        None,
        description="Notes about the generation process"
    )


# Rule definition type templates
RULE_TYPE_TEMPLATES = {
    "threshold": {
        "type": "threshold",
        "signal_type": "signal_type_here",
        "field": "field_path",
        "operator": "gt|lt|eq|gte|lte",
        "threshold": 0,
        "severity_on_breach": "high"
    },
    "change": {
        "type": "change",
        "signal_type": "signal_type_here",
        "field": "field_path",
        "change_threshold_percent": 10,
        "lookback_window": "24h",
        "severity_on_breach": "medium"
    },
    "presence": {
        "type": "presence",
        "required_signal_types": ["type1", "type2"],
        "within_window": "1h",
        "severity_on_absence": "low"
    },
    "combination": {
        "type": "combination",
        "operator": "and|or",
        "rules": [],
        "severity": "high"
    }
}


def validate_rule_definition(
    rule_def: Dict[str, Any],
    pack: str,
    valid_signal_types: List[str]
) -> List[str]:
    """
    Validate a rule definition.

    Args:
        rule_def: The rule definition to validate
        pack: Target pack
        valid_signal_types: Valid signal types for the pack

    Returns:
        List of validation errors (empty if valid)
    """
    errors = []

    if "type" not in rule_def:
        errors.append("Rule must have 'type' field")
        return errors

    rule_type = rule_def["type"]

    if rule_type == "threshold":
        if "signal_type" not in rule_def:
            errors.append("Threshold rule must have 'signal_type'")
        elif rule_def["signal_type"] not in valid_signal_types:
            errors.append(f"Unknown signal type: {rule_def['signal_type']}")

        if "field" not in rule_def:
            errors.append("Threshold rule must have 'field'")
        if "operator" not in rule_def:
            errors.append("Threshold rule must have 'operator'")
        if "threshold" not in rule_def:
            errors.append("Threshold rule must have 'threshold'")

    elif rule_type == "change":
        if "signal_type" not in rule_def:
            errors.append("Change rule must have 'signal_type'")
        elif rule_def["signal_type"] not in valid_signal_types:
            errors.append(f"Unknown signal type: {rule_def['signal_type']}")

        if "field" not in rule_def:
            errors.append("Change rule must have 'field'")
        if "change_threshold_percent" not in rule_def:
            errors.append("Change rule must have 'change_threshold_percent'")

    elif rule_type == "presence":
        if "required_signal_types" not in rule_def:
            errors.append("Presence rule must have 'required_signal_types'")
        else:
            for st in rule_def["required_signal_types"]:
                if st not in valid_signal_types:
                    errors.append(f"Unknown signal type: {st}")

    elif rule_type == "combination":
        if "rules" not in rule_def:
            errors.append("Combination rule must have 'rules'")
        else:
            for i, sub_rule in enumerate(rule_def["rules"]):
                sub_errors = validate_rule_definition(sub_rule, pack, valid_signal_types)
                for err in sub_errors:
                    errors.append(f"Sub-rule {i}: {err}")

    else:
        errors.append(f"Unknown rule type: {rule_type}")

    return errors
